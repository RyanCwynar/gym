// Auto-generated by generate-swift-client.ts
// DO NOT EDIT - Regenerate with: npx tsx scripts/generate-swift-client.ts

import Foundation
import ConvexMobile
import Combine

// MARK: - Generated Types

/// Exercise type enum matching Convex schema
enum ConvexExerciseType: String, Codable {
    case resistance
    case calisthenics
    case cardio
}

/// Set from Convex
struct ConvexSet: Codable, Identifiable {
    let _id: String
    let _creationTime: Double
    let apiKeyId: String
    let exerciseId: String?
    let exerciseName: String
    let weight: Double?
    let weightUnit: String?
    let reps: Int?
    let workTime: Int? // seconds
    let exerciseType: String
    let duration: Int? // seconds (for cardio)
    let notes: String?
    let isCompleted: Bool?
    let completedAt: Double?
    let workoutId: String?
    let setOrder: Int?
    
    var id: String { _id }
    
    var type: ConvexExerciseType {
        ConvexExerciseType(rawValue: exerciseType) ?? .resistance
    }
}

/// Exercise from Convex
struct ConvexExercise: Codable, Identifiable {
    let _id: String
    let _creationTime: Double
    let name: String
    let muscleGroup: String
    let description: String?
    let defaultWeight: Double?
    let defaultWeightUnit: String?
    let isPrimary: Bool?
    let exerciseType: String
    
    var id: String { _id }
}

/// Day stats response
struct ConvexDayStats: Codable {
    let totalWorkTime: Double
    let totalDuration: Double
    let setCount: Int
}

/// Day stats by type response
struct ConvexDayStatsByType: Codable {
    let resistance: ResistanceStats
    let calisthenics: CalisthenicsStats
    let cardio: CardioStats
    
    struct ResistanceStats: Codable {
        let setCount: Int
        let totalVolume: Double
        let totalWorkTime: Double
    }
    
    struct CalisthenicsStats: Codable {
        let setCount: Int
        let totalReps: Int
        let totalWorkTime: Double
    }
    
    struct CardioStats: Codable {
        let sessionCount: Int
        let totalDuration: Double
    }
}

// MARK: - Generated Convex Client

/// Type-safe Convex client generated from schema
@MainActor
class ConvexAPI: ObservableObject {
    static let shared = ConvexAPI()
    
    let client: ConvexClient
    
    @Published var apiKeyId: String?
    
    private let deploymentURL = "https://marvelous-cow-733.convex.cloud"
    private let apiKeyStorageKey = "convex_api_key_id"
    
    private init() {
        self.client = ConvexClient(deploymentUrl: deploymentURL)
        loadApiKeyId()
    }
    
    // MARK: - API Key Management
    
    func setApiKeyId(_ keyId: String) {
        apiKeyId = keyId
        UserDefaults.standard.set(keyId, forKey: apiKeyStorageKey)
    }
    
    func loadApiKeyId() {
        apiKeyId = UserDefaults.standard.string(forKey: apiKeyStorageKey)
    }
    
    var isAuthenticated: Bool {
        apiKeyId != nil && !(apiKeyId?.isEmpty ?? true)
    }
    
    // MARK: - Helpers
    
    /// Convert muscle group to ConvexExerciseType
    static func exerciseType(for muscleGroup: String) -> ConvexExerciseType {
        switch muscleGroup.lowercased() {
        case "cardio": return .cardio
        case "core", "abs", "bodyweight": return .calisthenics
        default: return .resistance
        }
    }
    
    /// Convert muscle group to exercise type string
    static func exerciseTypeString(for muscleGroup: String) -> String {
        exerciseType(for: muscleGroup).rawValue
    }
    
    // MARK: - Test Connection
    
    /// Test the connection by trying to fetch today's sets
    func testConnection() async throws -> Bool {
        guard let apiKeyId = apiKeyId else {
            throw ConvexAPIError.notAuthenticated
        }
        
        let calendar = Calendar.current
        let startOfDay = calendar.startOfDay(for: Date())
        let endOfDay = calendar.date(byAdding: .day, value: 1, to: startOfDay)!
        
        // Try to subscribe to a query - this will validate the API key
        let publisher = client.subscribe(
            to: "sets:getSetsByDay",
            with: [
                "apiKeyId": apiKeyId,
                "dayStartTimestamp": startOfDay.timeIntervalSince1970 * 1000,
                "dayEndTimestamp": endOfDay.timeIntervalSince1970 * 1000
            ],
            yielding: [ConvexSet]?.self
        ).replaceError(with: nil)
        
        // Try to get at least one value to confirm connection works
        for try await _ in publisher.values {
            return true
        }
        
        return false
    }
    
    // MARK: - Sets API
    
    /// Create a new set
    func createSet(
        exerciseName: String,
        exerciseType: ConvexExerciseType,
        exerciseId: String? = nil,
        weight: Double? = nil,
        weightUnit: String? = nil,
        reps: Int? = nil,
        workTime: Int? = nil, // seconds
        duration: Int? = nil, // seconds (for cardio)
        notes: String? = nil,
        isCompleted: Bool? = nil,
        workoutId: String? = nil,
        setOrder: Int? = nil
    ) async throws -> String {
        guard let apiKeyId = apiKeyId else {
            throw ConvexAPIError.notAuthenticated
        }
        
        // Build args dictionary, excluding nil values (Convex v.optional expects absent, not null)
        var args: [String: any ConvexEncodable] = [
            "apiKeyId": apiKeyId,
            "exerciseName": exerciseName,
            "exerciseType": exerciseType.rawValue,
            "weightUnit": weightUnit ?? "lbs"
        ]
        
        if let exerciseId = exerciseId { args["exerciseId"] = exerciseId }
        if let weight = weight { args["weight"] = weight }
        if let reps = reps { args["reps"] = reps }
        if let workTime = workTime { args["workTime"] = workTime }
        if let duration = duration { args["duration"] = duration }
        if let notes = notes { args["notes"] = notes }
        if let isCompleted = isCompleted { args["isCompleted"] = isCompleted }
        if let workoutId = workoutId { args["workoutId"] = workoutId }
        if let setOrder = setOrder { args["setOrder"] = setOrder }
        
        return try await client.mutation("sets:createSet", with: args)
    }
    
    /// Update an existing set
    func updateSet(
        setId: String,
        weight: Double? = nil,
        weightUnit: String? = nil,
        reps: Int? = nil,
        workTime: Int? = nil, // seconds
        duration: Int? = nil, // seconds (for cardio)
        notes: String? = nil,
        isCompleted: Bool? = nil
    ) async throws {
        guard let apiKeyId = apiKeyId else {
            throw ConvexAPIError.notAuthenticated
        }
        
        // Build args dictionary, excluding nil values
        var args: [String: any ConvexEncodable] = [
            "setId": setId,
            "apiKeyId": apiKeyId
        ]
        
        if let weight = weight { args["weight"] = weight }
        if let weightUnit = weightUnit { args["weightUnit"] = weightUnit }
        if let reps = reps { args["reps"] = reps }
        if let workTime = workTime { args["workTime"] = workTime }
        if let duration = duration { args["duration"] = duration }
        if let notes = notes { args["notes"] = notes }
        if let isCompleted = isCompleted { args["isCompleted"] = isCompleted }
        
        let _: String? = try await client.mutation("sets:updateSet", with: args)
    }
    
    /// Delete a set
    func deleteSet(setId: String) async throws {
        guard let apiKeyId = apiKeyId else {
            throw ConvexAPIError.notAuthenticated
        }
        
        let _: String? = try await client.mutation("sets:deleteSet", with: [
            "setId": setId,
            "apiKeyId": apiKeyId
        ])
    }
    
    /// Subscribe to sets for a specific day
    func subscribeToSetsByDay(
        dayStart: Date,
        dayEnd: Date
    ) -> AnyPublisher<[ConvexSet]?, Never> {
        guard let apiKeyId = apiKeyId else {
            return Just(nil).eraseToAnyPublisher()
        }
        
        return client.subscribe(
            to: "sets:getSetsByDay",
            with: [
                "apiKeyId": apiKeyId,
                "dayStartTimestamp": dayStart.timeIntervalSince1970 * 1000,
                "dayEndTimestamp": dayEnd.timeIntervalSince1970 * 1000
            ],
            yielding: [ConvexSet]?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    /// Subscribe to recent sets
    func subscribeToSets(limit: Int = 100) -> AnyPublisher<[ConvexSet]?, Never> {
        guard let apiKeyId = apiKeyId else {
            return Just(nil).eraseToAnyPublisher()
        }
        
        return client.subscribe(
            to: "sets:getSets",
            with: [
                "apiKeyId": apiKeyId,
                "limit": limit
            ],
            yielding: [ConvexSet]?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    /// Subscribe to sets by workout
    func subscribeToSetsByWorkout(workoutId: String) -> AnyPublisher<[ConvexSet]?, Never> {
        guard let apiKeyId = apiKeyId else {
            return Just(nil).eraseToAnyPublisher()
        }
        
        return client.subscribe(
            to: "sets:getSetsByWorkout",
            with: [
                "apiKeyId": apiKeyId,
                "workoutId": workoutId
            ],
            yielding: [ConvexSet]?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    /// Subscribe to day work time stats
    func subscribeToDayWorkTime(
        dayStart: Date,
        dayEnd: Date
    ) -> AnyPublisher<ConvexDayStats?, Never> {
        guard let apiKeyId = apiKeyId else {
            return Just(nil).eraseToAnyPublisher()
        }
        
        return client.subscribe(
            to: "sets:getDayWorkTime",
            with: [
                "apiKeyId": apiKeyId,
                "dayStartTimestamp": dayStart.timeIntervalSince1970 * 1000,
                "dayEndTimestamp": dayEnd.timeIntervalSince1970 * 1000
            ],
            yielding: ConvexDayStats?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    /// Subscribe to day stats by exercise type
    func subscribeToDayStatsByType(
        dayStart: Date,
        dayEnd: Date
    ) -> AnyPublisher<ConvexDayStatsByType?, Never> {
        guard let apiKeyId = apiKeyId else {
            return Just(nil).eraseToAnyPublisher()
        }
        
        return client.subscribe(
            to: "sets:getDayStatsByType",
            with: [
                "apiKeyId": apiKeyId,
                "dayStartTimestamp": dayStart.timeIntervalSince1970 * 1000,
                "dayEndTimestamp": dayEnd.timeIntervalSince1970 * 1000
            ],
            yielding: ConvexDayStatsByType?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    /// Subscribe to exercise history
    func subscribeToExerciseHistory(
        exerciseName: String,
        limit: Int = 20
    ) -> AnyPublisher<[ConvexSet]?, Never> {
        guard let apiKeyId = apiKeyId else {
            return Just(nil).eraseToAnyPublisher()
        }
        
        return client.subscribe(
            to: "sets:getExerciseHistory",
            with: [
                "apiKeyId": apiKeyId,
                "exerciseName": exerciseName,
                "limit": limit
            ],
            yielding: [ConvexSet]?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    // MARK: - Exercises API
    
    /// Subscribe to all exercises
    func subscribeToExercises() -> AnyPublisher<[ConvexExercise]?, Never> {
        return client.subscribe(
            to: "exercises:getExercises",
            yielding: [ConvexExercise]?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    /// Subscribe to exercises by muscle group
    func subscribeToExercisesByMuscleGroup(
        muscleGroup: String
    ) -> AnyPublisher<[ConvexExercise]?, Never> {
        return client.subscribe(
            to: "exercises:getExercisesByMuscleGroup",
            with: ["muscleGroup": muscleGroup],
            yielding: [ConvexExercise]?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    /// Subscribe to exercises by type
    func subscribeToExercisesByType(
        exerciseType: ConvexExerciseType
    ) -> AnyPublisher<[ConvexExercise]?, Never> {
        return client.subscribe(
            to: "exercises:getExercisesByType",
            with: ["exerciseType": exerciseType.rawValue],
            yielding: [ConvexExercise]?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    /// Search exercises
    func subscribeToExerciseSearch(
        searchTerm: String
    ) -> AnyPublisher<[ConvexExercise]?, Never> {
        return client.subscribe(
            to: "exercises:searchExercises",
            with: ["searchTerm": searchTerm],
            yielding: [ConvexExercise]?.self
        ).replaceError(with: nil).eraseToAnyPublisher()
    }
    
    /// Create a new exercise
    func createExercise(
        name: String,
        muscleGroup: String,
        exerciseType: ConvexExerciseType,
        description: String? = nil,
        defaultWeight: Double? = nil,
        defaultWeightUnit: String? = nil,
        isPrimary: Bool? = nil
    ) async throws -> String {
        return try await client.mutation("exercises:createExercise", with: [
            "name": name,
            "muscleGroup": muscleGroup,
            "exerciseType": exerciseType.rawValue,
            "description": description,
            "defaultWeight": defaultWeight,
            "defaultWeightUnit": defaultWeightUnit,
            "isPrimary": isPrimary
        ])
    }
}

// MARK: - Errors

enum ConvexAPIError: LocalizedError {
    case notAuthenticated
    case invalidResponse
    
    var errorDescription: String? {
        switch self {
        case .notAuthenticated:
            return "No API key configured. Go to Settings to add one."
        case .invalidResponse:
            return "Invalid response from server."
        }
    }
}